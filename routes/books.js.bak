var express = require('express');
var router = express.Router();
var dbConn  = require('../lib/db');

// display books page
router.get('/', async function(req, res, next) {
    const page = parseInt(req.query.page) || 1;
    const limit = 10;
    const offset = (page - 1) * limit;    const search = req.query.search || '';
    const filterCategory = req.query.category || '';
    const filterPublisher = req.query.publisher || '';

    // Muestra solo libros activos (state = 1)
    let where = 'WHERE b.state = 1';
    let params = [];

    if (search) {
        where += ' AND (b.name LIKE ? OR b.isbn LIKE ?)';
        params.push(`%${search}%`, `%${search}%`);
    }
    if (filterCategory) {
        where += ' AND b.id_category = ?';
        params.push(filterCategory);
    }
    if (filterPublisher) {
        where += ' AND b.id_publisher = ?';
        params.push(filterPublisher);
    }

    try {
        // Consulta principal con paginación
        const [rows] = await dbConn.query(`
            SELECT b.*, 
                   a.name as author_name, 
                   p.name as publisher_name, 
                   c.name as category_name 
            FROM books b
            LEFT JOIN authors a ON b.id_author = a.id_author
            LEFT JOIN publishers p ON b.id_publisher = p.id_publisher
            LEFT JOIN categories c ON b.id_category = c.id_category
            ${where}
            ORDER BY b.id_book DESC
            LIMIT ? OFFSET ?
        `, [...params, limit, offset]);

        // Consulta para el total de resultados (para la paginación)
        const [countRows] = await dbConn.query(`
            SELECT COUNT(*) as total FROM books b
            LEFT JOIN authors a ON b.id_author = a.id_author
            LEFT JOIN publishers p ON b.id_publisher = p.id_publisher
            LEFT JOIN categories c ON b.id_category = c.id_category
            ${where}
        `, params);

        const total = countRows[0].total;
        const totalPages = Math.ceil(total / limit);

        // También puedes pasar las categorías/editoriales para los filtros
        const [categories] = await dbConn.query('SELECT * FROM categories');
        const [publishers] = await dbConn.query('SELECT * FROM publishers');

        res.render('books/index', {            data: rows,
            page,
            totalPages,
            search,
            filterCategory,
            filterPublisher,
            categories,
            publishers
        });    } catch (err) {
        // En caso de error, pasar todas las variables necesarias con valores por defecto
        res.render('books/index', {
            data: [],
            page: 1,
            totalPages: 1,
            search: '',
            filterCategory: '',
            filterPublisher: '',
            categories: [],
            publishers: []
        });
    }
});

// display add book page
router.get('/add', async function(req, res, next) {
    try {
        const [authors] = await dbConn.query('SELECT id_author, name FROM authors ORDER BY name');
        const [categories] = await dbConn.query('SELECT id_category, name FROM categories ORDER BY name');
        const [publishers] = await dbConn.query('SELECT id_publisher, name FROM publishers ORDER BY name');
        res.render('books/add', {
            authors: authors,
            categories: categories,
            publishers: publishers,
            name: '',
            isbn: '',
            year_published: '',
            num_pages: '',
            id_author: '',
            id_category: '',
            id_publisher: '',
            state: 1
        });
    } catch (err) {
        console.error('Error fetching data for add book page:', err);
        req.flash('error', err.message || 'Error al cargar los datos para la página de agregar libro.');
        res.render('books/add', { authors: [], categories: [], publishers: [], name: '', isbn: '', year_published: '', num_pages: '', id_author: '', id_category: '', id_publisher: '', state: 1 });
    }
});

// add a new book
router.post('/add', async function(req, res, next) {
    let { name, id_author, id_category, id_publisher, isbn, year_published, num_pages, state } = req.body;
    let errors = false;
    if (name.length === 0 || !id_author || !id_category || !id_publisher || !year_published) {
        errors = true;
        req.flash('error', "Por favor ingrese nombre, autor, categoría, editorial y año de publicación.");
        try {
            const [authors] = await dbConn.query('SELECT id_author, name FROM authors ORDER BY name');
            const [categories] = await dbConn.query('SELECT id_category, name FROM categories ORDER BY name');
            const [publishers] = await dbConn.query('SELECT id_publisher, name FROM publishers ORDER BY name');
            res.render('books/add', { authors, categories, publishers, name, isbn, year_published, num_pages, id_author, id_category, id_publisher, state });
        } catch (dbErr) {
            console.error('Error fetching data for add book page after validation error:', dbErr);
            req.flash('error', dbErr.message || 'Error al cargar datos después de un error de validación.');
            res.render('books/add', { authors: [], categories: [], publishers: [], name, isbn, year_published, num_pages, id_author, id_category, id_publisher, state });
        }
    } else {
        var form_data = { name, id_author, id_category, id_publisher, isbn, year_published, num_pages, state };
        dbConn.query('INSERT INTO books SET ?', form_data, async function(err, result) {
            if (err) {
                console.error('Error inserting book:', err);
                req.flash('error', err.message || 'Error al agregar el libro.');
                try {
                    const [authors] = await dbConn.query('SELECT id_author, name FROM authors ORDER BY name');
                    const [categories] = await dbConn.query('SELECT id_category, name FROM categories ORDER BY name');
                    const [publishers] = await dbConn.query('SELECT id_publisher, name FROM publishers ORDER BY name');
                    res.render('books/add', { authors, categories, publishers, ...form_data });
                } catch (dbErr) {
                    console.error('Error fetching data for add book page after insert error:', dbErr);
                    req.flash('error', dbErr.message || 'Error al recargar datos después de un error de inserción.');
                    res.render('books/add', { authors: [], categories: [], publishers: [], ...form_data });
                }
            } else {
                req.flash('success', 'Libro agregado exitosamente.');
                res.redirect('/books/');
            }
        });
    }
});

// display edit book page
router.get('/edit/:id_book', async function(req, res, next) {
    let id_book = req.params.id_book;
    try {
        const [bookRows] = await dbConn.query('SELECT * FROM books WHERE id_book = ?', [id_book]);
        const [authors] = await dbConn.query('SELECT id_author, name FROM authors ORDER BY name');
        const [categories] = await dbConn.query('SELECT id_category, name FROM categories ORDER BY name');
        const [publishers] = await dbConn.query('SELECT id_publisher, name FROM publishers ORDER BY name');
        if (!bookRows || bookRows.length === 0) {
            req.flash('error', 'Libro no encontrado con id_book = ' + id_book);
            res.redirect('/books/');
        } else {
            const book = bookRows[0];
            res.render('books/edit', {
                title: 'Editar Libro',
                id_book: book.id_book,
                name: book.name,
                isbn: book.isbn,
                year_published: book.year_published,
                num_pages: book.num_pages,
                id_author: book.id_author,
                id_category: book.id_category,
                id_publisher: book.id_publisher,
                state: book.state,
                authors: authors,
                categories: categories,
                publishers: publishers
            });
        }
    } catch (err) {
        console.error('Error fetching data for edit book page:', err);
        req.flash('error', err.message || 'Error al cargar los datos para editar el libro.');
        res.redirect('/books/');
    }
});

// update book data
router.post('/update/:id_book', async function(req, res, next) {
    let id_book = req.params.id_book;
    let { name, id_author, id_category, id_publisher, isbn, year_published, num_pages, state } = req.body;
    let errors = false;
    if (name.length === 0 || !id_author || !id_category || !id_publisher || !year_published) {
        errors = true;
        req.flash('error', "Por favor ingrese nombre, autor, categoría, editorial y año de publicación.");
        try {
            const [authors] = await dbConn.query('SELECT id_author, name FROM authors ORDER BY name');
            const [categories] = await dbConn.query('SELECT id_category, name FROM categories ORDER BY name');
            const [publishers] = await dbConn.query('SELECT id_publisher, name FROM publishers ORDER BY name');
            res.render('books/edit', { title: 'Editar Libro', id_book, name, isbn, year_published, num_pages, id_author, id_category, id_publisher, state, authors, categories, publishers });
        } catch (dbErr) {
            console.error('Error fetching data for edit book page after validation error:', dbErr);
            req.flash('error', dbErr.message || 'Error al cargar datos para editar después de un error de validación.');
            res.render('books/edit', { title: 'Editar Libro', id_book, name, isbn, year_published, num_pages, id_author, id_category, id_publisher, state, authors: [], categories: [], publishers: [] });
        }
    } else {
        var form_data = { name, id_author, id_category, id_publisher, isbn, year_published, num_pages, state };
        dbConn.query('UPDATE books SET ? WHERE id_book = ?', [form_data, id_book], async function(err, result) {
            if (err) {
                console.error('Error updating book:', err);
                req.flash('error', err.message || 'Error al actualizar el libro.');
                try {
                    const [authors] = await dbConn.query('SELECT id_author, name FROM authors ORDER BY name');
                    const [categories] = await dbConn.query('SELECT id_category, name FROM categories ORDER BY name');
                    const [publishers] = await dbConn.query('SELECT id_publisher, name FROM publishers ORDER BY name');
                    res.render('books/edit', { title: 'Editar Libro', id_book, ...form_data, authors, categories, publishers });
                } catch (dbErr) {
                    console.error('Error fetching data for edit book page after update error:', dbErr);
                    req.flash('error', dbErr.message || 'Error al recargar datos para editar después de un error de actualización.');
                    res.render('books/edit', { title: 'Editar Libro', id_book, ...form_data, authors: [], categories: [], publishers: [] });
                }
            } else {
                req.flash('success', 'Libro actualizado exitosamente.');
                res.redirect('/books/');
            }
        });
    }
});

// soft delete book using POST method (update state to 0)
router.post('/deactivate', async function(req, res, next) {
    console.log('Petición POST de desactivación recibida. Body:', req.body);
    let id_book = req.body.id_book;
    
    // Validar que tenemos un ID
    if (!id_book) {
        console.error('ERROR CRÍTICO: ID de libro no proporcionado en la petición');
        req.flash('error', 'Error: No se proporcionó el ID del libro');
        return res.redirect('/books/');
    }
    
    console.log('ID de libro a desactivar:', id_book, 'Tipo:', typeof id_book);
    
    try {        // Ejecución directa de la actualización 
        console.log('Ejecutando consulta directa para el libro:', id_book);
        const sqlQuery = 'UPDATE books SET state = 0 WHERE id_book = ? AND state = 1';
        console.log('SQL Query a ejecutar:', sqlQuery, 'con parámetro:', id_book);
        
        const [result] = await dbConn.query(sqlQuery, [id_book]);
        
        console.log('Resultado de la actualización:', result);
        
        if (result && result.affectedRows > 0) {
            // Si la actualización fue exitosa, ahora obtenemos el nombre para el mensaje
            const [bookInfo] = await dbConn.query('SELECT name FROM books WHERE id_book = ?', [id_book]);
            const bookName = bookInfo && bookInfo.length > 0 ? bookInfo[0].name : 'Libro #' + id_book;
            
            console.log(`Libro "${bookName}" desactivado exitosamente. Filas afectadas: ${result.affectedRows}`);
            req.flash('success', `Libro "${bookName}" desactivado exitosamente. Puede restaurarlo desde la sección de restauración.`);
        } else {
            console.log('No se realizaron cambios. Es posible que el libro ya esté desactivado o no exista.');
            req.flash('warning', 'No se pudo desactivar el libro. Puede que ya esté desactivado o no exista.');
        }
    } catch (err) {
        console.error('Error crítico desactivando libro:', err);
        req.flash('error', 'Error al desactivar el libro: ' + (err.message || 'Error desconocido'));
    }
    
    console.log('Redirigiendo a /books/');
    res.redirect('/books/');
});

// Ruta GET para desactivar libros, utilizada desde el modal
router.get('/deactivate/:id_book', async function(req, res, next) {
    let id_book = req.params.id_book;
    console.log('Petición GET de desactivación recibida para libro ID:', id_book);
    
    try {
        // Primero verificamos el estado actual del libro
        const [bookRows] = await dbConn.query('SELECT name, state FROM books WHERE id_book = ?', [id_book]);
        
        if (!bookRows || bookRows.length === 0) {
            console.log('Error: Libro no encontrado');
            req.flash('error', 'Libro no encontrado');
            return res.redirect('/books/');
        }
        
        const bookName = bookRows[0].name;
        const currentState = bookRows[0].state;
        
        console.log(`Libro encontrado: "${bookName}", Estado actual: ${currentState}`);
        
        if (currentState === 0) {
            console.log('El libro ya está desactivado');
            req.flash('warning', `El libro "${bookName}" ya está desactivado.`);
            return res.redirect('/books/');
        }
        
        // Ejecutar la actualización del estado
        console.log('Actualizando estado del libro a inactivo (0)');
        const [updateResult] = await dbConn.query(
            'UPDATE books SET state = ? WHERE id_book = ?', 
            [0, id_book]
        );
        
        console.log('Resultado de actualización:', updateResult);
        
        if (updateResult.affectedRows > 0) {
            console.log(`Libro "${bookName}" desactivado exitosamente`);
            req.flash('success', `Libro "${bookName}" desactivado exitosamente. Puede restaurarlo desde la sección de restauración.`);
        } else {
            console.log('La actualización no afectó a ninguna fila');
            req.flash('warning', `No se pudo desactivar el libro "${bookName}". Intente nuevamente.`);
        }
    } catch (err) {
        console.error('Error desactivando libro:', err);
        req.flash('error', 'Error al desactivar el libro: ' + (err.message || 'Error desconocido'));
    }
    
    console.log('Redirigiendo a /books/');
    res.redirect('/books/');
});

// delete book (kept for compatibility, but not used)
router.get('/delete/:id_book', async function(req, res, next) {
    // Redirigir a la nueva ruta de desactivación
    res.redirect('/books/deactivate/' + req.params.id_book);
});

// toggle book state
router.post('/toggle-state/:id_book', async function(req, res, next) {
    let id_book = req.params.id_book;
    
    console.log('Solicitud de cambio de estado para libro ID:', id_book);
    
    try {
        // Primero obtenemos el estado actual
        const [bookRows] = await dbConn.query('SELECT state FROM books WHERE id_book = ?', [id_book]);
        
        if (!bookRows || bookRows.length === 0) {
            const errorMsg = 'Libro no encontrado';
            console.log('Error:', errorMsg);
            req.flash('error', errorMsg);
            return res.redirect('/books/');
        }

        // Calculamos el nuevo estado (1 -> 0, 0 -> 1)
        const currentState = bookRows[0].state;
        const newState = currentState === 1 ? 0 : 1;
        console.log(`Cambiando estado de ${currentState} a ${newState}`);

        // Actualizamos el estado
        await dbConn.query('UPDATE books SET state = ? WHERE id_book = ?', [newState, id_book]);
        
        const successMsg = `Libro ${newState === 1 ? 'activado' : 'desactivado'} exitosamente`;
        console.log('Éxito:', successMsg);
        
        // Mensaje de éxito y redirección
        req.flash('success', successMsg);
        
        // Redirigir a la misma página
        const referer = req.get('Referer');
        res.redirect(referer || '/books/');
    } catch (err) {
        console.error('Error al cambiar el estado del libro:', err);
        const errorMsg = err.message || 'Error al cambiar el estado del libro';
        
        req.flash('error', errorMsg);
        res.redirect('/books/');
    }
});

// display restore books page
router.get('/restore', async function(req, res, next) {
    const page = parseInt(req.query.page) || 1;
    const limit = 10;
    const offset = (page - 1) * limit;

    try {
        // Consulta principal con paginación para libros inactivos (state = 0)
        const [rows] = await dbConn.query(`
            SELECT b.*, 
                   a.name as author_name, 
                   p.name as publisher_name, 
                   c.name as category_name 
            FROM books b
            LEFT JOIN authors a ON b.id_author = a.id_author
            LEFT JOIN publishers p ON b.id_publisher = p.id_publisher
            LEFT JOIN categories c ON b.id_category = c.id_category
            WHERE b.state = 0
            ORDER BY b.name ASC
            LIMIT ? OFFSET ?
        `, [limit, offset]);

        // Consulta para el total de libros inactivos (para la paginación)
        const [countRows] = await dbConn.query(`
            SELECT COUNT(*) as total FROM books WHERE state = 0
        `);

        const total = countRows[0].total;
        const totalPages = Math.ceil(total / limit);

        res.render('books/restore', {
            data: rows,
            page,
            totalPages,
            title: 'Restaurar Libros'
        });
    } catch (err) {
        console.error('Error al cargar la página de restauración:', err);
        req.flash('error', err.message || 'Error al cargar la página de restauración');
        res.redirect('/books');
    }
});

// activate book from restore page
router.post('/activate/:id_book', async function(req, res, next) {
    const id_book = req.params.id_book;
    const currentPage = req.body.currentPage || 1;
    
    console.log('Solicitud de activación para libro ID:', id_book);
    
    try {
        // Verificar que el libro existe y está inactivo
        const [bookRows] = await dbConn.query('SELECT * FROM books WHERE id_book = ? AND state = 0', [id_book]);
        
        if (!bookRows || bookRows.length === 0) {
            const errorMsg = 'Libro no encontrado o ya está activo';
            console.log('Error:', errorMsg);
            req.flash('error', errorMsg);
            return res.redirect(`/books/restore?page=${currentPage}`);
        }

        // Activar el libro (cambiar state de 0 a 1)
        await dbConn.query('UPDATE books SET state = 1 WHERE id_book = ?', [id_book]);
        
        const successMsg = `Libro "${bookRows[0].name}" activado exitosamente`;
        console.log('Éxito:', successMsg);
        
        // Mensaje de éxito y redirección
        req.flash('success', successMsg);
        res.redirect(`/books/restore?page=${currentPage}`);
    } catch (err) {
        console.error('Error al activar el libro:', err);
        const errorMsg = err.message || 'Error al activar el libro';
        
        req.flash('error', errorMsg);
        res.redirect(`/books/restore?page=${currentPage}`);
    }
});

module.exports = router;